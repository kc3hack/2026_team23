// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}
 
generator client {
  provider = "prisma-client"
  output   = "../generated"

  binaryTargets = ["native" ,"rshel-openssl-3.0x"]
}
 
model User {
  id            String          @id @default(cuid())
  name          String?
  email         String?         @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
  // Optional for WebAuthn support
  Authenticator Authenticator[]
  projects      ProjectMember[] 
  groupMembers GroupMember[]
  notifications Notification[]
  pushSubscriptions PushSubscription[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
 
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@unique([provider, providerAccountId])
}
 
model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
 
model VerificationToken {
  identifier String
  token      String
  expires    DateTime
 
  @@unique([identifier, token])
}
 
// Optional for WebAuthn support
model Authenticator {
  credentialID         String  @unique
  userId               String
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@id([userId, credentialID])
}

// 1. User テーブル (ユーザー情報)
//Google認証で作成されたUserテーブルを利用するためここは省略しますかーー


// 2. Project テーブル (旅行自体の情報)


model Project {
  id            String          @id @default(uuid())
  title         String          // 例: "卒業旅行", "冬の温泉" など
  description   String
  departureDate DateTime        // 出発日程 (アプリ側で3ヶ月後にバリデーション)
  endDate       DateTime
  price         Int
  
  //グループ情報追加
  groupId      String?
  group        Group?          @relation(fields: [groupId], references: [id],onDelete: SetNull)
  // このプロジェクトに参加するメンバー（中間テーブルへのリレーション）
  members       ProjectMember[] 

  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt
}

// --------------------------------------------------
// 3. ProjectMember テーブル (★これが中間テーブル★)
// --------------------------------------------------
model ProjectMember {
  id            String   @id @default(uuid())
  
  // 外部キー
  projectId     String
  userId        String
  
  // リレーションの定義 (Cascade: プロジェクトやユーザーが消えたらこの紐付けも消す)
  project       Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // この参加者の「役割」と「回答状況」をここに持たせる！
  role          Role     @default(PARTICIPANT)
  status        Status   @default(PENDING)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // ★重要: 同じ人が同じプロジェクトに2回登録されるのを防ぐ制約
  @@unique([projectId, userId]) 
}

//-------
// 4. グループテーブル作成(グループを一括で登録できるようにするため)
//---------
model Group {
  id    String  @id @default(uuid())
  name  String //大学の友達みたいな感じのグループ名が入るかな
  description String? //説明(?つくやつは任意でなくてもOK)

  members  GroupMember[] //所属メンバー
  projects Project[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

//5. GroupMemberテーブル(UserとGroupの中間テーブル)

model GroupMember {
  id     String @id @default(uuid())

  groupId String 
  userId  String

  group Group @relation(fields:[groupId],references:[id],onDelete:Cascade)
  user  User  @relation(fields:[userId], references: [id], onDelete:Cascade)

  role GroupRole @default(MEMBER)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupId,userId])
}

model Notification {
  id        String   @id @default(uuid())
  userId    String   // 通知を受け取るユーザー
  type      NotificationType // 通知の種類（招待、更新など）
  title     String   // 通知タイトル
  message   String   // 通知内容
  link      String?  // クリックした時の遷移先URL（例: /projects/123）
  isRead    Boolean  @default(false) // 既読フラグ

  createdAt DateTime @default(now())
  
  // リレーション定義
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId]) // 高速化のためのインデックス
}
// 通知を購読しているかどうかの管理DB
model PushSubscription {
  id        String   @id @default(uuid())
  userId    String
  endpoint  String   // 必須: 通知の届け先URL
  p256dh    String   // 必須: 暗号化キー
  auth      String   // 必須: 認証シークレット
  
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // 同一ブラウザからの重複登録を防ぐ
  @@unique([endpoint])
}
// --------------------------------------------------
// Enum (列挙型) - 取りうる値を固定して安全にする
// --------------------------------------------------
enum Role {
  MASTER       // 主催者
  PARTICIPANT  // 招待された参加者
}

enum Status {
  PENDING   // 通知済み・未回答 (デフォルト)
  ACCEPTED  // はい (参加)
  DECLINED  // いいえ (不参加)
}

enum GroupRole {
  ADMIN   //グループの管理者
  MEMBER //招待を受けるメンバー
}

enum NotificationType {
  INVITATION  // プロジェクトへの招待
  REMIND      // 日程が近づいています
  POINT       // 特定の誰かからつつかれたとき
  SYSTEM      // システムからのお知らせ
}
